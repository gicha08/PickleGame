<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pocket Pickleball Pro 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Outfit', sans-serif;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 30px;
            box-sizing: border-box;
        }

        .glass {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 15px 30px;
            color: white;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.4);
        }

        #score-board {
            display: flex;
            gap: 40px;
            font-size: 24px;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .score-unit {
            text-align: center;
        }

        .score-label {
            font-size: 12px;
            opacity: 0.6;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        #message {
            font-size: 64px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 4px;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #message.show {
            opacity: 1;
            transform: scale(1);
        }

        #hint {
            font-size: 18px;
            opacity: 0.8;
            transition: opacity 0.5s;
        }

        canvas {
            display: block;
            touch-action: none;
            cursor: crosshair;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700;900&display=swap" rel="stylesheet">
</head>

<body>
    <div id="ui">
        <div id="score-board" class="glass">
            <div class="score-unit">
                <div class="score-label">Player</div>
                <div id="player-score">0</div>
            </div>
            <div style="width: 1px; background: rgba(255,255,255,0.2);"></div>
            <div class="score-unit">
                <div class="score-label">Opponent</div>
                <div id="opponent-score">0</div>
            </div>
        </div>

        <div id="message">Ready?</div>

        <div id="hint" class="glass">Move mouse/finger to control paddle</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- Config ---
        const COURT_W = 6.1;
        const COURT_L = 13.41;
        const NET_H = 0.914;
        const BALL_R = 0.07; // Increased size for visibility
        const PADDLE_W = 0.22;
        const PADDLE_H = 0.38;

        // --- Setup Scene ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1c2c);
        scene.fog = new THREE.FogExp2(0x1a1c2c, 0.04);

        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2.5, 9);
        camera.lookAt(0, 0.8, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- Physics ---
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        const ballMat = new CANNON.Material('ball');
        const courtMat = new CANNON.Material('court');
        const paddleMat = new CANNON.Material('paddle');
        world.addContactMaterial(new CANNON.ContactMaterial(ballMat, courtMat, { friction: 0.05, restitution: 0.75 })); // Reduced restitution slightly to prevent "superball" effect
        world.addContactMaterial(new CANNON.ContactMaterial(ballMat, paddleMat, { friction: 0.3, restitution: 0.8 }));

        // --- Lights ---
        const ambient = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambient);

        const spot = new THREE.SpotLight(0xffffff, 100);
        spot.position.set(5, 10, 5);
        spot.angle = 0.5;
        spot.penumbra = 0.5;
        spot.castShadow = true;
        spot.shadow.mapSize.width = 2048;
        spot.shadow.mapSize.height = 2048;
        spot.shadow.bias = -0.0001; // Reduce shadow acne/flickering
        scene.add(spot);

        const point = new THREE.PointLight(0x4488ff, 50);
        point.position.set(-5, 5, -5);
        scene.add(point);

        // --- Environment ---
        // Floor
        const floorGeo = new THREE.CircleGeometry(40, 32);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.1; // Lowered significantly to avoid z-fighting
        floor.receiveShadow = true;
        scene.add(floor);

        // Court
        const courtGroup = new THREE.Group();
        const courtSurface = new THREE.Mesh(
            new THREE.PlaneGeometry(COURT_W, COURT_L),
            new THREE.MeshStandardMaterial({ color: 0x24628a, roughness: 0.9 })
        );
        courtSurface.rotation.x = -Math.PI / 2;
        courtSurface.position.y = 0.0; // At zero
        courtSurface.receiveShadow = true;
        courtGroup.add(courtSurface);

        // Lines (Simplified)
        const lineGeo = new THREE.PlaneGeometry(COURT_W, 0.05);
        const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const addLine = (w, h, x, z, rot = 0) => {
            const l = new THREE.Mesh(new THREE.PlaneGeometry(w, h), lineMat);
            l.rotation.x = -Math.PI / 2;
            l.rotation.z = rot;
            l.position.set(x, 0.02, z);
            courtGroup.add(l);
        };
        addLine(COURT_W, 0.05, 0, COURT_L / 2);     // Baseline near
        addLine(COURT_W, 0.05, 0, -COURT_L / 2);    // Baseline far
        addLine(0.05, COURT_L, COURT_W / 2, 0);    // Sideline L
        addLine(0.05, COURT_L, -COURT_W / 2, 0);   // Sideline R
        addLine(COURT_W, 0.05, 0, 2.13);         // Kitchen near
        addLine(COURT_W, 0.05, 0, -2.13);        // Kitchen far
        addLine(0.05, COURT_L - 4.26, 0, 0);     // Mid line
        scene.add(courtGroup);

        const courtBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane() });
        courtBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        world.addBody(courtBody);

        // Net
        const netGroup = new THREE.Group();
        // Dense wireframe for better visibility (60x10 segments)
        const netMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(COURT_W + 0.4, NET_H, 60, 10),
            new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.5 })
        );
        netMesh.position.y = NET_H / 2;
        netGroup.add(netMesh);

        // White tape on top
        const tape = new THREE.Mesh(new THREE.BoxGeometry(COURT_W + 0.4, 0.05, 0.04), new THREE.MeshBasicMaterial({ color: 0xffffff }));
        tape.position.y = NET_H;
        netGroup.add(tape);

        // Black posts on sides
        const postGeo = new THREE.CylinderGeometry(0.04, 0.04, NET_H + 0.05);
        const postMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const postL = new THREE.Mesh(postGeo, postMat);
        postL.position.set(-(COURT_W / 2 + 0.2), NET_H / 2, 0);
        netGroup.add(postL);
        const postR = postL.clone();
        postR.position.set((COURT_W / 2 + 0.2), NET_H / 2, 0);
        netGroup.add(postR);

        scene.add(netGroup);
        world.addBody(new CANNON.Body({ mass: 0, position: new CANNON.Vec3(0, NET_H / 2, 0), shape: new CANNON.Box(new CANNON.Vec3(COURT_W / 2, NET_H / 2, 0.02)) }));

        // Ball
        const ballMesh = new THREE.Mesh(
            new THREE.SphereGeometry(BALL_R, 32, 32),
            new THREE.MeshStandardMaterial({ color: 0xccff00, emissive: 0xccff00, emissiveIntensity: 0.2 })
        );
        ballMesh.castShadow = true;
        scene.add(ballMesh);
        const ballBody = new CANNON.Body({ mass: 0.026, shape: new CANNON.Sphere(BALL_R), material: ballMat, linearDamping: 0.1 });
        world.addBody(ballBody);
        const resetBall = () => { ballBody.position.set(0, 10, 0); ballBody.velocity.set(0, 0, 0); ballBody.sleep(); };
        resetBall();

        // Paddle
        const paddleGroup = new THREE.Group();
        const paddleFace = new THREE.Mesh(new THREE.BoxGeometry(PADDLE_W, PADDLE_H, 0.02), new THREE.MeshStandardMaterial({ color: 0xe63946 }));
        paddleFace.castShadow = true;
        paddleGroup.add(paddleFace);
        const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.15), new THREE.MeshStandardMaterial({ color: 0x222222 }));
        handle.position.y = -0.25;
        paddleGroup.add(handle);
        scene.add(paddleGroup);

        // Physics body is much larger than visual mesh for generous hit zone
        // Visual width: PADDLE_W (0.22), Physics width: 0.6 (approx 3x)
        // Visual height: PADDLE_H (0.38), Physics height: 0.6 (approx 1.5x)
        const paddleBody = new CANNON.Body({
            mass: 0,
            type: CANNON.Body.KINEMATIC,
            material: paddleMat,
            shape: new CANNON.Box(new CANNON.Vec3(0.3, 0.4, 0.1)) // Large hit box
        });
        world.addBody(paddleBody);

        // Opponent (Simulated dummy)
        const opp = new THREE.Mesh(new THREE.CapsuleGeometry(0.2, 1, 4, 8), new THREE.MeshStandardMaterial({ color: 0x457b9d }));
        opp.position.set(0, 1, -COURT_L / 2 - 0.5);
        scene.add(opp);

        // --- Gameplay Logic ---
        let gameState = 'IDLE';
        let playerScore = 0, opponentScore = 0;
        let lastPaddleY = 0;

        const showMsg = (txt) => {
            const el = document.getElementById('message');
            el.innerText = txt; el.classList.add('show');
            setTimeout(() => el.classList.remove('show'), 1500);
        };

        const serve = () => {
            gameState = 'PLAY';
            resetBall();
            ballBody.wakeUp();
            // Serve from just in front of opponent (opp z is approx -7.2)
            ballBody.position.set((Math.random() - 0.5) * 3, 1.5, -6.5);
            // Dynamic serve speed based on difficulty or random
            const vz = 7 + Math.random() * 3; // Ensure it reaches player
            const vy = 3 + Math.random() * 2;
            const vx = (Math.random() - 0.5) * 2;
            ballBody.velocity.set(vx, vy, vz);
            document.getElementById('hint').style.opacity = 0;
        };

        // Collision callback
        // Collision callback
        ballBody.addEventListener('collide', (e) => {
            if (e.body === paddleBody) {
                // Precision Control Logic:
                // Swipe speed (dy) determines shot type.
                // 0.0 - 0.2: Drop Shot (Slow, moderate arc to clear net)
                // > 0.2: Drive/Smash (Fast, flatter arc)

                const dy = Math.max(0, (mouse.y - lastPaddleY) * 50);

                let speedZ, speedY;

                if (dy < 0.25) {
                    // DROP SHOT
                    // Low speed to just clear the net (7m distance)
                    speedZ = 5 + (dy * 4); // Range: 5 to ~6
                    speedY = 4.2; // High arc to clear net safely
                    showMsg('DROP');
                } else {
                    // DRIVE / SMASH
                    // Higher speed, trajectory flattens slightly with power
                    speedZ = 8 + (dy * 5); // Range: 8 to 13+
                    speedY = 3.5 + (dy * 1.5);
                    showMsg(dy > 0.8 ? 'SMASH!' : 'DRIVE');
                }

                // Apply Velocity
                // Note: Z is negative to go towards opponent
                ballBody.velocity.z = -Math.min(speedZ, 15);
                ballBody.velocity.y = Math.min(speedY, 8);

                // Steering
                ballBody.velocity.x = mouse.x * 4;
            }
        });

        // Update Hint
        document.getElementById('hint').innerText = "Swipe SLOW for Drop, FAST for Smash!";

        // --- Controls ---
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        const planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), -6.5);
        const intersectPoint = new THREE.Vector3();

        const updatePaddle = (x, y) => {
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(planeZ, intersectPoint);

            const tx = THREE.MathUtils.clamp(intersectPoint.x, -COURT_W / 2 - 0.5, COURT_W / 2 + 0.5);
            const ty = THREE.MathUtils.clamp(intersectPoint.y, 0.2, 2.5);

            paddleBody.position.set(tx, ty, 6.5);
            paddleGroup.position.copy(paddleBody.position);

            // Visual tilt
            paddleGroup.rotation.x = -0.2 + mouse.y * 0.3;
            paddleGroup.rotation.y = mouse.x * 0.4;
            paddleBody.quaternion.copy(paddleGroup.quaternion);

            lastPaddleY = mouse.y;
        };

        window.addEventListener('pointermove', e => updatePaddle(e.clientX, e.clientY));
        window.addEventListener('pointerdown', () => { if (gameState === 'IDLE') serve(); });

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);
            world.step(1 / 60);

            ballMesh.position.copy(ballBody.position);
            ballMesh.quaternion.copy(ballBody.quaternion);

            // Dynamic Ball Scaling
            // Range: z = -7 (far) to +7 (near)
            const z = ballBody.position.z;
            const scale = 1 + Math.max(0, (z + 7) / 14) * 0.8;
            ballMesh.scale.setScalar(scale);

            // Bounds / Scoring
            if (gameState === 'PLAY') {
                if (ballBody.position.y < -0.5 || Math.abs(ballBody.position.z) > 15) {
                    if (ballBody.position.z > 0) {
                        opponentScore++;
                        showMsg('OPPONENT POINT');
                    } else {
                        playerScore++;
                        showMsg('PLAYER POINT');
                    }
                    document.getElementById('player-score').innerText = playerScore;
                    document.getElementById('opponent-score').innerText = opponentScore;
                    gameState = 'IDLE';
                    resetBall();
                    setTimeout(() => { if (gameState === 'IDLE') serve(); }, 2000);
                }
            }

            // Slight camera follow
            camera.position.x += (mouse.x * 0.5 - camera.position.x) * 0.05;
            camera.lookAt(0, 0.8, 0);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize
        showMsg('Ready?');
        setTimeout(serve, 2000);
        animate();
    </script>
</body>

</html>