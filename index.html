<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pocket Pickleball (PlayCanvas)</title>
    <style>
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Outfit', sans-serif;
        }

        #application {
            width: 100%;
            height: 100%;
            display: block;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 30px;
            box-sizing: border-box;
        }

        .glass {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 15px 30px;
            color: white;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.4);
        }

        #score-board {
            display: flex;
            gap: 40px;
            font-size: 24px;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .score-unit {
            text-align: center;
        }

        .score-label {
            font-size: 12px;
            opacity: 0.6;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        #message {
            font-size: 64px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 4px;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #message.show {
            opacity: 1;
            transform: scale(1);
        }

        #hint {
            font-size: 18px;
            opacity: 0.8;
            transition: opacity 0.5s;
            text-align: center;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700;900&display=swap" rel="stylesheet">

    <!-- PlayCanvas Engine (v2.0 - matches ammo.751ec5f build) -->
    <script src="https://code.playcanvas.com/playcanvas-stable.min.js"></script>
    <!-- Ammo.js Physics -->
    <script src="https://code.playcanvas.com/ammo.751ec5f.js"></script>
</head>

<body>
    <canvas id="application"></canvas>

    <div id="ui">
        <div id="score-board" class="glass">
            <div class="score-unit">
                <div class="score-label">Player</div>
                <div id="player-score">0</div>
            </div>
            <div style="width: 1px; background: rgba(255,255,255,0.2);"></div>
            <div class="score-unit">
                <div class="score-label">Opponent</div>
                <div id="opponent-score">0</div>
            </div>
        </div>

        <div id="message">Loading...</div>
        <div id="hint" class="glass">Swipe SLOW for Drop, FAST for Smash!</div>
    </div>

    <script>
        // Use an IIFE to keep global scope clean
        (function () {
            const startApp = () => {
                if (typeof Ammo === 'function') {
                    // Likely WASM build, needs initialization
                    Ammo().then(initGame);
                } else {
                    // Likely asm.js build or already initialized
                    initGame();
                }
            };

            if (typeof Ammo !== 'undefined') {
                startApp();
            } else {
                window.addEventListener('load', () => {
                    if (typeof Ammo !== 'undefined') {
                        startApp();
                    } else {
                        console.error("Ammo.js failed to load!");
                    }
                });
            }

            function initGame() {
                try {
                console.log('[PocketPickleball] initGame called, Ammo type:', typeof Ammo);

                // Shim missing methods for older Ammo.js builds
                if (Ammo.btRigidBody && Ammo.btRigidBody.prototype && !Ammo.btRigidBody.prototype.setRollingFriction) {
                    Ammo.btRigidBody.prototype.setRollingFriction = function () {};
                    Ammo.btRigidBody.prototype.setSpinningFriction = function () {};
                    console.log('[PocketPickleball] Shimmed missing Ammo.js friction methods');
                }

                // --- Constants ---
                const COURT_W = 6.1;
                const COURT_L = 13.41;
                const NET_H = 0.914;
                const BALL_R = 0.07;

                // --- Create Application ---
                const canvas = document.getElementById('application');
                const app = new pc.Application(canvas, {
                    mouse: new pc.Mouse(canvas),
                    touch: new pc.TouchDevice(canvas),
                    elementInput: new pc.ElementInput(canvas),
                    keyboard: new pc.Keyboard(window)
                });

                // Start app first - initializes physics (Ammo.js) system
                app.start();

                // Set fill mode to fill the window
                app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
                app.setCanvasResolution(pc.RESOLUTION_AUTO);

                // Ensure canvas resizes when window changes
                window.addEventListener('resize', () => app.resizeCanvas());

                // --- Setup Scene ---
                // Add Light
                const light = new pc.Entity('DirectionalLight');
                light.addComponent('light', {
                    type: 'directional',
                    color: new pc.Color(1, 1, 1),
                    castShadows: true,
                    intensity: 1.2,
                    shadowBias: 0.2,
                    normalOffsetBias: 0.05,
                    shadowDistance: 20
                });
                light.setLocalEulerAngles(45, 30, 0);
                app.root.addChild(light);

                const ambient = new pc.Entity('AmbientLight');
                ambient.addComponent('light', {
                    type: 'point',
                    color: new pc.Color(0.8, 0.8, 1),
                    intensity: 0.5,
                    range: 100
                });
                ambient.setPosition(0, 10, 0);
                app.root.addChild(ambient);

                // Add Camera
                const camera = new pc.Entity('MainCamera');
                camera.addComponent('camera', {
                    clearColor: new pc.Color(0.1, 0.11, 0.17), // Dark blue-ish bg
                    farClip: 100,
                    fov: 60
                });
                camera.setPosition(0, 2.5, 9);
                camera.lookAt(0, 0.8, 0);
                app.root.addChild(camera);

                // --- Materials ---
                const createMaterial = (color) => {
                    const material = new pc.StandardMaterial();
                    material.diffuse = color;
                    material.update();
                    return material;
                };
                const matCourt = createMaterial(new pc.Color(0.14, 0.38, 0.54)); // 0x24628a
                const matLine = createMaterial(new pc.Color(1, 1, 1));
                const matNet = createMaterial(new pc.Color(1, 1, 1));
                matNet.rollOffFactor = 0; // Simple wireframe-ish look
                matNet.opacity = 0.3;
                matNet.blendType = pc.BLEND_NORMAL;
                matNet.update();

                const matBall = createMaterial(new pc.Color(0.8, 1.0, 0)); // #ccff00
                matBall.emissive = new pc.Color(0.2, 0.25, 0);
                matBall.update();

                const matPaddle = createMaterial(new pc.Color(0.9, 0.22, 0.27)); // #e63946
                const matDark = createMaterial(new pc.Color(0.1, 0.1, 0.1));

                // --- Environment ---

                // Floor (Visual only, below court)
                const floor = new pc.Entity('Floor');
                floor.addComponent('render', { type: 'cylinder' });
                floor.setLocalScale(40, 0.1, 40);
                floor.setLocalPosition(0, -0.15, 0);
                floor.render.material = matDark;
                app.root.addChild(floor);

                // Court Base (Physics + Visual)
                const court = new pc.Entity('Court');
                court.addComponent('render', { type: 'plane' });
                court.setLocalScale(COURT_W, 1, COURT_L);
                court.setLocalPosition(0, 0, 0);
                court.render.material = matCourt;
                // Add collision/rigidbody
                court.addComponent('collision', { type: 'box', halfExtents: new pc.Vec3(COURT_W / 2, 0.1, COURT_L / 2) });
                court.addComponent('rigidbody', { type: 'static', friction: 0.1, restitution: 0.75 });
                // Note: Plane visual is flat, but collision box needs depth. We offset pos slightly
                // PlayCanvas plane faces Y up.
                app.root.addChild(court);

                // Court Friction Fix (Since PC doesn't have fine-grained material pairs easily accessible in JS API without deep dive, we rely on body properties)

                // Lines
                const addLine = (w, l, x, z) => {
                    const line = new pc.Entity();
                    line.addComponent('render', { type: 'plane' });
                    line.setLocalScale(w, 1, l);
                    line.setLocalPosition(x, 0.01, z); // Raised
                    line.render.material = matLine;
                    app.root.addChild(line);
                };
                addLine(COURT_W, 0.05, 0, COURT_L / 2);
                addLine(COURT_W, 0.05, 0, -COURT_L / 2);
                addLine(0.05, COURT_L, COURT_W / 2, 0);
                addLine(0.05, COURT_L, -COURT_W / 2, 0);
                addLine(COURT_W, 0.05, 0, 2.13);
                addLine(COURT_W, 0.05, 0, -2.13);
                addLine(0.05, COURT_L - 4.26, 0, 0);

                // Net
                const net = new pc.Entity('Net');
                const netVis = new pc.Entity('NetVisual');
                netVis.addComponent('render', { type: 'box' });
                netVis.setLocalScale(COURT_W + 0.4, NET_H, 0.02);
                netVis.setLocalPosition(0, NET_H / 2, 0);
                netVis.render.material = matNet;

                const tape = new pc.Entity('NetTape');
                tape.addComponent('render', { type: 'box' });
                tape.setLocalScale(COURT_W + 0.4, 0.05, 0.05);
                tape.setLocalPosition(0, NET_H, 0);
                tape.render.material = matLine;

                const postL = new pc.Entity('PostL');
                postL.addComponent('render', { type: 'cylinder' });
                postL.setLocalScale(0.08, NET_H + 0.1, 0.08);
                postL.setLocalPosition(-(COURT_W / 2 + 0.2), NET_H / 2, 0);
                postL.render.material = matDark;

                const postR = new pc.Entity('PostR');
                postR.addComponent('render', { type: 'cylinder' });
                postR.setLocalScale(0.08, NET_H + 0.1, 0.08);
                postR.setLocalPosition(COURT_W / 2 + 0.2, NET_H / 2, 0);
                postR.render.material = matDark;

                net.addChild(netVis); net.addChild(tape); net.addChild(postL); net.addChild(postR);
                net.setLocalPosition(0, 0, 0);
                app.root.addChild(net);

                // Net collider - separate entity so collision center matches visual center
                const netCol = new pc.Entity('NetCollider');
                netCol.addComponent('collision', { type: 'box', halfExtents: new pc.Vec3(COURT_W / 2 + 0.2, NET_H / 2, 0.05) });
                netCol.addComponent('rigidbody', { type: 'static' });
                netCol.setLocalPosition(0, NET_H / 2, 0);
                app.root.addChild(netCol);

                // --- Opponent ---
                const matSkin = createMaterial(new pc.Color(0.85, 0.65, 0.5));
                const matShirt = createMaterial(new pc.Color(0.2, 0.4, 0.8));
                const matShorts = createMaterial(new pc.Color(0.15, 0.15, 0.15));
                const matShoe = createMaterial(new pc.Color(1, 1, 1));

                const opponent = new pc.Entity('Opponent');
                // Kitchen line is at z = -2.13
                opponent.setLocalPosition(0, 0, -2.13);

                // Torso
                const torso = new pc.Entity('Torso');
                torso.addComponent('render', { type: 'box' });
                torso.setLocalScale(0.4, 0.5, 0.25);
                torso.setLocalPosition(0, 1.2, 0);
                torso.render.material = matShirt;
                opponent.addChild(torso);

                // Head
                const head = new pc.Entity('Head');
                head.addComponent('render', { type: 'sphere' });
                head.setLocalScale(0.22, 0.22, 0.22);
                head.setLocalPosition(0, 1.6, 0);
                head.render.material = matSkin;
                opponent.addChild(head);

                // Hat/visor
                const hat = new pc.Entity('Hat');
                hat.addComponent('render', { type: 'cylinder' });
                hat.setLocalScale(0.26, 0.04, 0.26);
                hat.setLocalPosition(0, 1.72, 0);
                hat.render.material = matDark;
                opponent.addChild(hat);

                // Shorts
                const shorts = new pc.Entity('Shorts');
                shorts.addComponent('render', { type: 'box' });
                shorts.setLocalScale(0.38, 0.2, 0.24);
                shorts.setLocalPosition(0, 0.85, 0);
                shorts.render.material = matShorts;
                opponent.addChild(shorts);

                // Legs
                const addLeg = (xOff) => {
                    const leg = new pc.Entity();
                    leg.addComponent('render', { type: 'box' });
                    leg.setLocalScale(0.12, 0.5, 0.12);
                    leg.setLocalPosition(xOff, 0.5, 0);
                    leg.render.material = matSkin;
                    opponent.addChild(leg);
                    const shoe = new pc.Entity();
                    shoe.addComponent('render', { type: 'box' });
                    shoe.setLocalScale(0.14, 0.08, 0.2);
                    shoe.setLocalPosition(xOff, 0.22, 0.04);
                    shoe.render.material = matShoe;
                    opponent.addChild(shoe);
                };
                addLeg(-0.1);
                addLeg(0.1);

                // Arms
                const addArm = (xOff, rz) => {
                    const arm = new pc.Entity();
                    arm.addComponent('render', { type: 'box' });
                    arm.setLocalScale(0.1, 0.4, 0.1);
                    arm.setLocalPosition(xOff, 1.1, 0);
                    arm.setLocalEulerAngles(0, 0, rz);
                    arm.render.material = matSkin;
                    opponent.addChild(arm);
                };
                addArm(-0.28, 15);  // left arm slightly out
                addArm(0.28, -30);  // right arm holding paddle

                // Opponent paddle
                const oppPaddle = new pc.Entity('OppPaddle');
                oppPaddle.addComponent('render', { type: 'box' });
                oppPaddle.setLocalScale(0.18, 0.28, 0.02);
                oppPaddle.setLocalPosition(0.4, 0.95, 0.15);
                oppPaddle.setLocalEulerAngles(10, 0, -20);
                oppPaddle.render.material = matPaddle;
                opponent.addChild(oppPaddle);

                app.root.addChild(opponent);

                // --- Gameplay Entities ---

                // Ball
                const ball = new pc.Entity('Ball');
                ball.addComponent('render', { type: 'sphere' });
                ball.render.material = matBall;
                ball.setLocalScale(BALL_R * 2, BALL_R * 2, BALL_R * 2);
                ball.addComponent('collision', { type: 'sphere', radius: BALL_R });
                ball.addComponent('rigidbody', {
                    type: 'dynamic',
                    mass: 0.026,
                    restitution: 0.8,
                    linearDamping: 0.1,
                    angularDamping: 0.1
                });
                ball.setPosition(0, 5, 0);
                ball.enabled = false; // Start hidden
                app.root.addChild(ball);

                // Paddle
                const paddle = new pc.Entity('Paddle');
                const paddleVis = new pc.Entity('PaddleVis');
                paddleVis.addComponent('render', { type: 'box' });
                paddleVis.setLocalScale(0.22, 0.38, 0.02);
                paddleVis.render.material = matPaddle;

                const paddleHandle = new pc.Entity('PaddleHandle');
                paddleHandle.addComponent('render', { type: 'cylinder' });
                paddleHandle.setLocalScale(0.04, 0.15, 0.04);
                paddleHandle.setLocalPosition(0, -0.26, 0);
                paddleHandle.render.material = matDark;

                paddle.addChild(paddleVis);
                paddle.addChild(paddleHandle);

                // Hit Box (Physics Only)
                // Much larger than visual
                paddle.addComponent('collision', { type: 'box', halfExtents: new pc.Vec3(0.3, 0.4, 0.1) });
                paddle.addComponent('rigidbody', { type: 'kinematic' });
                paddle.setPosition(0, 1, 6.5);
                app.root.addChild(paddle);

                // --- Logic & State ---
                let gameState = 'IDLE';
                let playerScore = 0, opponentScore = 0;
                let lastMouseY = 0;
                let lastPaddlePos = new pc.Vec3();

                // UI Helpers
                const msgEl = document.getElementById('message');
                const showMsg = (txt) => {
                    msgEl.innerText = txt;
                    msgEl.classList.add('show');
                    setTimeout(() => msgEl.classList.remove('show'), 1000);
                };
                showMsg('READY?');

                // Game Loop
                const resetBall = () => {
                    ball.rigidbody.teleport(0, 10, 0);
                    ball.rigidbody.linearVelocity = pc.Vec3.ZERO;
                    ball.rigidbody.angularVelocity = pc.Vec3.ZERO;
                    ball.enabled = false;
                };

                const serve = () => {
                    gameState = 'PLAY';
                    ball.enabled = true;
                    // Serve from opponent at kitchen line (z = -2.13)
                    const oppPos = opponent.getPosition();
                    const sx = oppPos.x + (Math.random() - 0.5) * 0.5;
                    ball.rigidbody.teleport(sx, 1.3, oppPos.z);
                    ball.rigidbody.activate();

                    // Controlled serve toward player - always reachable
                    const vz = 6 + Math.random() * 3;
                    const vy = 2.5 + Math.random() * 1.5;
                    const vx = (Math.random() - 0.5) * 2;

                    ball.rigidbody.linearVelocity = new pc.Vec3(vx, vy, vz);
                    document.getElementById('hint').style.opacity = 0;
                };

                // Paddle Control
                // We need a plane to raycast against at Z=6.5
                // Z-plane at 6.5 facing Z axis
                const controlPlanePoint = new pc.Vec3(0, 0, 6.5);
                const controlPlaneNormal = new pc.Vec3(0, 0, 1);

                const ray = new pc.Ray();
                const hitPoint = new pc.Vec3();

                // Hit Zone: extremely generous - ball just needs to be on player's half
                const canHit = (ballWorldPos) => {
                    return ballWorldPos.z > 0 && ballWorldPos.y > -0.5;
                };

                let swipeStartPos = new pc.Vec2();
                let swipeStartTime = 0;
                let isSwiping = false;

                // Input Listeners for Swipe
                window.addEventListener('pointerdown', (e) => {
                    if (gameState === 'IDLE') {
                        serve();
                    } else if (gameState === 'PLAY') {
                        isSwiping = true;
                        swipeStartTime = performance.now();
                        swipeStartPos.set(e.clientX, e.clientY);
                    }
                });

                window.addEventListener('pointerup', (e) => {
                    if (!isSwiping || gameState !== 'PLAY') return;
                    isSwiping = false;

                    const ballPos = ball.getPosition();

                    // Check Hit Zone
                    if (canHit(ballPos)) {
                        const dt = (performance.now() - swipeStartTime) / 1000;
                        const dx = e.clientX - swipeStartPos.x;
                        const dy = swipeStartPos.y - e.clientY; // Up is positive

                        // Calculate Speed (px/s)
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const speed = dist / Math.max(dt, 0.01);

                        // Determine Shot
                        // Thresholds: Slow < 500, Fast > 1500
                        const intensity = Math.min(1, Math.max(0, (speed - 200) / 2000));

                        let speedZ, speedY;

                        if (intensity < 0.25) {
                            // Drop
                            speedZ = 5 + intensity * 8; // 5 to 7
                            speedY = 4 + intensity * 2;
                            showMsg('DROP');
                        } else {
                            // Drive / Smash
                            speedZ = 9 + intensity * 15; // 9 to 24
                            speedY = 3 + intensity * 4;
                            showMsg('SMASH!');
                        }

                        // Steering based on swipe X direction
                        const steerX = dx / window.innerWidth * 15;

                        // Launch
                        ball.rigidbody.linearVelocity = new pc.Vec3(
                            steerX,
                            Math.min(speedY, 8),
                            -Math.min(speedZ, 22)
                        );

                        // Add some top spin based on intensity
                        ball.rigidbody.angularVelocity = new pc.Vec3(intensity * 20, 0, 0);
                    }
                });

                // Custom Input Handling for Raycast
                window.addEventListener('pointermove', (e) => {
                    // Convert to -1..1
                    const x = (e.clientX / window.innerWidth) * 2 - 1;
                    const y = -(e.clientY / window.innerHeight) * 2 + 1;

                    // Update Camera Look slightly
                    camera.lookAt(x * 0.5, 0.8 + y * 0.5, 0);

                    // Raycast for Paddle
                    const start = new pc.Vec3();
                    const end = new pc.Vec3();
                    camera.camera.screenToWorld(e.clientX, e.clientY, camera.camera.nearClip, start);
                    camera.camera.screenToWorld(e.clientX, e.clientY, camera.camera.farClip, end);

                    ray.origin.copy(start);
                    ray.direction.copy(end).sub(start).normalize();

                    // Manual Ray-Plane Intersection
                    // t = ((planePoint - rayOrigin) . planeNormal) / (rayDir . planeNormal)
                    const denom = ray.direction.dot(controlPlaneNormal);
                    if (Math.abs(denom) > 1e-6) {
                        const vec = new pc.Vec3().sub2(controlPlanePoint, ray.origin);
                        const t = vec.dot(controlPlaneNormal) / denom;

                        if (t >= 0) {
                            hitPoint.copy(ray.origin).add(ray.direction.clone().scale(t));

                            // Clamp
                            const px = pc.math.clamp(hitPoint.x, -COURT_W / 2 - 0.5, COURT_W / 2 + 0.5);
                            const py = pc.math.clamp(hitPoint.y, 0.2, 2.5);

                            lastPaddlePos.copy(paddle.getPosition());
                            paddle.rigidbody.teleport(px, py, 6.5);

                            // Visual Tilt
                            paddle.setLocalEulerAngles(-10 + py * 5, px * 10, 0);

                            lastMouseY = py; // Store World Y for speed calc
                        }
                    }
                });

                // Game Loop Logic
                console.log('[PocketPickleball] Setting up game loop...');
                app.on('update', (dt) => {
                    if (gameState === 'PLAY' && ball.enabled) {
                        const bPos = ball.getPosition();

                        // Ball growing effect
                        // Z range: -7 to 7
                        const scale = 1 + pc.math.clamp((bPos.z + 7) / 14, 0, 1) * 0.8;
                        ball.setLocalScale(BALL_R * 2 * scale, BALL_R * 2 * scale, BALL_R * 2 * scale);

                        // Scoring / Out Bounds
                        if (Math.abs(bPos.z) > 15 || bPos.y < -0.2) {
                            if (bPos.z > 0) {
                                opponentScore++;
                                showMsg('OPPONENT POINT');
                            } else {
                                playerScore++;
                                showMsg('PLAYER POINT');
                            }

                            // Update Score UI
                            document.getElementById('player-score').innerText = playerScore;
                            document.getElementById('opponent-score').innerText = opponentScore;

                            gameState = 'IDLE';
                            resetBall();
                            setTimeout(() => {
                                if (gameState === 'IDLE') serve();
                            }, 2000);
                        }
                    }
                });

                console.log('[PocketPickleball] Game setup complete');

                } catch (err) {
                    console.error('[PocketPickleball] Init error:', err);
                    document.getElementById('message').innerText = 'Error: ' + err.message;
                    document.getElementById('message').classList.add('show');
                }
            }
        })();
    </script>
</body>

</html>